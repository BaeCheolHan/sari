# FastMCP 도입 계획서 (단일 데몬 수집 포함)

## 0. 목적
- MCP 통신 안정화 (프레이밍/핸드셰이크/클라이언트 호환성 문제 제거)
- 단일 데몬에서 수집(인덱싱) 책임을 고정
- stdio는 항상 데몬 프록시로만 동작

---

## 1. 범위

### 포함
- FastMCP 서버를 데몬 프로세스에 통합
- stdio 경로는 데몬 프록시 유지
- 수집(인덱싱) 단일 책임: 데몬에서만 수행
- feature flag로 병행 운영 가능

### 제외
- 무중단 배포
- SSE/streamable-http 도입
- 완전한 프로세스 분리(인덱싱 워커 분리) — 후속 단계

---

## 2. 현재 구조 요약

- stdio: `python -m sari --transport stdio` → 프록시 → 데몬
- 데몬: TCP 기반 MCP 세션 처리
- transport: 자체 구현(`sari.mcp.transport`)

---

## 3. 목표 구조

```
[Client stdio]
   └─ sari (stdio) → proxy → daemon(FastMCP)

[Client http]
   └─ daemon(FastMCP)

[수집/인덱싱]
   └─ daemon 단일 책임
```

---

## 4. 단계별 도입 계획

### 단계 1: FastMCP 병행 추가
- feature flag: `SARI_FASTMCP=1`
- 데몬에서 FastMCP 서버를 선택적으로 구동
- 기존 서버 유지 (fallback 가능)

### 단계 2: stdio 경로 고정 유지
- stdio는 무조건 프록시
- 로컬 stdio 서버 직접 실행 경로 제거

### 단계 3: 수집/인덱싱 단일 책임 고정
- 인덱싱 요청은 데몬에서만 처리
- 프록시는 요청 전달만 수행
- 워크스페이스 단위 중복 스캔 방지(락/상태 관리)

### 단계 4: 기본값 전환
- FastMCP를 기본값으로 전환
- 기존 transport는 fallback만 유지
- 전환 조건:
  - Gemini/Codex stdio 연속 100회 연결 성공
  - 전체 테스트 270+ 통과
  - 30분 이상 연속 실행 시 오류/락 누적 없음

### 단계 5: fallback 제거
- 최소 2주 운영 후 문제 없음이 확인되면 fallback 제거

---

## 5. 리스크 및 대응

### 리스크 A: 도구 스키마 호환
- Codex/OpenAI 툴 스키마 호환 필요
- 대응: Serena 방식 스키마 정규화 레이어

### 리스크 B: 성능 저하
- FastMCP 이벤트 루프 구조 영향 가능
- 대응: 큐/워커 설계 유지, 성능 측정

### 리스크 C: 데몬 단일 책임 강화에 따른 부하
- 멀티클라이언트 집중
- 대응: 큐 제한/백프레셔/락 정책

### 리스크 D: 인증/접근 제어
- HTTP 노출 시 보안 위험
- 대응: loopback 고정 유지, 원격 접근 금지

---

## 6. 검증 계획

- Gemini/Codex stdio 연결 안정성
- 데몬 단일 책임(인덱싱 중복 없음)
- 270+ 테스트 통과
- 장시간 실행 시 오류/락 누적 없음
- 재현 시나리오:
  - Gemini + Codex 동시 접속
  - 대규모 워크스페이스 인덱싱 중 요청 처리
  - 데몬 재시작 후 재연결

---

## 7. 운영 정책

- 업데이트 시 모든 CLI/데몬 종료 후 재시작
- stdio는 데몬 필수
- HTTP는 별도 프로세스
- loopback 전용 정책 유지

---

## 8. 산출물

- FastMCP 서버 통합 코드
- feature flag 운영 문서
- 통합 테스트 결과

---

## 9. 추가 개선 여지 (현재 기준 최선 점검)

### 가능한 추가 개선
- 인덱싱 워커 분리(프로세스 분리)
- 스냅샷 DB 교체 방식 도입
- SSE/streamable-http 도입

### 현재 기준 최선 여부
- **통신 안정화만 목표로 하면 현재 계획이 최선**
- **운영 안정성까지 극대화하려면 위 추가 개선 필요**

