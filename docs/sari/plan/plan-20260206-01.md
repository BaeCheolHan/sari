# sari 소스코드 분석 (2026-02-06)

## 범위
- 대상: `sari` 레포 핵심 런타임/인덱싱/MCP 경로
- 파일: `sari/main.py`, `sari/core/main.py`, `sari/core/workspace.py`, `sari/core/indexer/main.py`, `sari/core/indexer/scanner.py`,
  `sari/mcp/server.py`, `sari/mcp/daemon.py`, `sari/mcp/proxy.py`, `sari/core/db/main.py`, `sari/__main__.py`

## 진입점 요약
- `sari/__main__.py`: 패키지 엔트리 → `sari.main.main()` 호출.
- `sari/main.py`: CLI/서브커맨드 라우팅 + MCP stdio 프로토콜 보호를 위해 stdout→stderr 전환.
- `sari/core/main.py`: HTTP 서버/인덱서 기동(워크스페이스 자동 감지, 엔진 초기화, HTTP 즉시 기동).
- `sari/mcp/server.py`: MCP JSON-RPC 서버(도구 호출/프로토콜 협상/daemon thin-adapter).
- `sari/mcp/daemon.py`: TCP 데몬(레지스트리/워크스페이스 오토스타트/하트비트).
- `sari/mcp/proxy.py`: 클라이언트↔데몬 프록시(잠금 기반 데몬 기동/재연결/프레이밍).

## 워크스페이스/설정 경로
- `WorkspaceManager.resolve_workspace_root()`가 `rootUri/workspaceFolders` → env → CWD 순으로 결론.
- `resolve_config_path()`는 `SARI_CONFIG` → `.sari/mcp-config.json` → `~/.config/sari/config.json` 순.
- 레거시 `.sari/config.json`은 JSON 유효 시만 `mcp-config.json`으로 1회 마이그레이션.

## 인덱싱 파이프라인
- `Indexer.run_forever()`:
  - 워커 스레드 기동 → 루트 등록 → `FileWatcher` 시작 → `scan_once()` → 큐 기반 지속 처리.
- `scan_once()`:
  - staging 생성 → 루트별 파일 스캔 → 공정 큐(fair queue) 적재.
- `_worker_loop()`:
  - 백프레셔/읽기 우선 정책 적용 → 작업 처리 → 스캔 종료 시 prune + staging merge.
- 파일 변경 이벤트:
  - 생성/수정은 fast-track로 L1 버퍼를 우회해 즉시 반영.
  - 삭제는 버퍼에서 제거 후 스토리지 삭제.

## 스캐너 정책
- 하드코딩 제외 디렉토리/글롭 + 사용자 제외 규칙 + gitignore 병합.
- `PathTrie`로 서브 워크스페이스 중복 스캔 방지.
- `include_ext/include_files`가 있으면 필터링 모드로 전환.

## MCP/HTTP 연계
- HTTP 서버는 인덱싱 전 즉시 기동, MCP 서버는 필요 시 생성.
- MCP 서버는 데몬 레지스트리 조회 후 thin-adapter로 포워딩 가능.
- 데몬은 레지스트리에 등록하고 워크스페이스 자동 기동/하트비트/idle shutdown 수행.

## DB/엔진 경계
- `LocalSearchDB`는 SQLite 기반 + 엔진 어댑터로 검색 위임(`search_v2`).
- `root_id` 기반 멀티 테넌시 SQL 필터 제공(`apply_root_filter`).

## 리스크/확인 필요
- MCP 표준 출력 보호를 위해 `sari/main.py`가 stdout을 stderr로 전환하므로, 추가 CLI는 출력 스트림 주의 필요.
- 데몬/프록시/서버 3축 경로가 있어, 문서/설정/레지스트리 경로 불일치 시 진단 난이도 상승 가능.

## 다음 액션
- 테스트/운영 관점에서 `daemon`↔`proxy`↔`server` 연결 시나리오 점검.
- `WorkspaceManager`의 루트 결정 정책과 실제 설치/사용 가이드를 동기화.
