#!/bin/bash
# Generated by Horadric Forge
# Deckard Bootstrapper (Zero-Install)

REQUIRED_VERSION="__REQUIRED_VERSION__"
ZIP_URL="__ZIP_URL__"

# 1. 환경 설정
TARGET_DIR="$(cd "$(dirname "$0")" && pwd)"
cd "$TARGET_DIR"

# 로깅 설정
mkdir -p logs
LOG_FILE="logs/bootstrap.log"
log() {
    # stderr로 출력하여 MCP 통신 방해 금지
    # 로그 파일에도 기록 (실패 시 무시)
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [Bootstrapper] $1" | tee -a "$LOG_FILE" >&2 2>/dev/null || echo "[Bootstrapper] $1" >&2
}

# 파이썬 환경 정화 (Sanitize)
unset PYTHONPATH
unset PYTHONHOME

# 2. 동시성 제어 (Lock)
LOCK_DIR="provision.lock"
MAX_RETRIES=30
RETRY_COUNT=0
while ! mkdir "$LOCK_DIR" 2>/dev/null; do
    log "다른 프로세스가 설치 중입니다. 대기 중..."
    sleep 2
    RETRY_COUNT=$((RETRY_COUNT + 1))
    if [ $RETRY_COUNT -ge $MAX_RETRIES ]; then
        log "Error: Lock timeout. (provision.lock 파일을 수동으로 삭제해 보세요)"
        exit 1
    fi
done
# 스크립트 종료 시 Lock 해제
trap 'rm -rf "$LOCK_DIR"' EXIT

# 3. Python 런타임 체크 (Runtime Check)
if ! command -v python3 &>/dev/null; then 
    log "Error: python3 명령어를 찾을 수 없습니다."
    exit 1
fi

# 버전 정밀 체크 (3.8+)
python3 -c "import sys; sys.exit(0 if sys.version_info >= (3, 8) else 1)" 2>/dev/null
if [ $? -ne 0 ]; then
    log "Error: Python 3.8 이상이 필요합니다."
    exit 1
fi

# 4. 버전 확인 및 프로비저닝
INSTALLED_VERSION=""
if [ -f "version.txt" ]; then
    INSTALLED_VERSION=$(cat version.txt)
fi

# 업데이트 조건: 버전 불일치 AND 다운로드 URL 존재
if [ "$INSTALLED_VERSION" != "$REQUIRED_VERSION" ] && [ -n "$ZIP_URL" ]; then
    log "버전 업데이트 시작 ($INSTALLED_VERSION -> $REQUIRED_VERSION)..."
    
    # 안전한 임시 폴더
    TEMP_DIR=".tmp_install"
    rm -rf "$TEMP_DIR"
    mkdir -p "$TEMP_DIR"
    
    # 다운로드
    log "다운로드 중: $ZIP_URL"
    curl -sL -o "$TEMP_DIR/tool.zip" "$ZIP_URL"
    if [ $? -ne 0 ]; then
        log "Error: 다운로드 실패."
        rm -rf "$TEMP_DIR"
        exit 1
    fi
    
    # 압축 해제
    # unzip 유무 체크? -> 보통 있지만, 없으면 python zipfile로 대체 가능. 
    # 여기선 unzip 필수 가정.
    unzip -q "$TEMP_DIR/tool.zip" -d "$TEMP_DIR/extract"
    
    # 루트 폴더 찾기 (GitHub Archive는 폴더 안에 들어있음)
    # mcp 폴더를 포함하는 상위 폴더를 찾음
    SRC_ROOT=$(find "$TEMP_DIR/extract" -maxdepth 2 -type d -name "mcp" | head -n 1 | xargs dirname)
    if [ -z "$SRC_ROOT" ]; then
        SRC_ROOT="$TEMP_DIR/extract"
    fi

    # 무결성 검증 (Integrity Check)
    if [ ! -f "$SRC_ROOT/mcp/server.py" ]; then
        log "Error: 패키지 구조가 잘못되었습니다 (server.py 없음)."
        rm -rf "$TEMP_DIR"
        exit 1
    fi

    # 파일 교체 (Atomic-ish Swap)
    log "파일 갱신 중..."
    
    # 1. 기존 코드 삭제 (Config, Data, Lock, Logs, Temp 제외)
    # find . -maxdepth 1 ... -exec rm -rf {} +
    # 실수 방지를 위해 명시적 제외 목록 사용
    find . -maxdepth 1 \
        ! -name 'bootstrap.sh' \
        ! -name 'data' \
        ! -name 'config' \
        ! -name 'logs' \
        ! -name 'provision.lock' \
        ! -name '.tmp_install' \
        ! -name '.' \
        ! -name '..' \
        -exec rm -rf {} +
    
    # 2. 새 코드 복사 (Config, Data 제외)
    # cp -R로 복사하되, SRC_ROOT 안의 config/data는 제외하고 복사
    find "$SRC_ROOT" -maxdepth 1 \
        ! -name 'config' \
        ! -name 'data' \
        ! -name "$(basename "$SRC_ROOT")" \
        -exec cp -R {} . \;
    
    # 3. 설정 파일 병합 (Smart Merge)
    # 새 버전의 기본 설정파일(config/*.json)이 기존 사용자 설정을 덮어쓰면 안 됨.
    if [ -d "$SRC_ROOT/config" ]; then
        mkdir -p config
        for f in "$SRC_ROOT/config/"*;
        do
            if [ -f "$f" ]; then
                FNAME=$(basename "$f")
                if [ ! -f "config/$FNAME" ]; then
                    cp "$f" "config/"
                    log "새 설정 파일 추가: $FNAME"
                fi
            fi
        done
    fi
    
    # 4. 버전 기록
    echo "$REQUIRED_VERSION" > version.txt
    rm -rf "$TEMP_DIR"
    log "업데이트 완료"
fi

# 5. 실행
# 버전 정보를 환경변수로 주입 (Tag-Driven 연동)
export DECKARD_VERSION="$REQUIRED_VERSION"
exec python3 mcp/server.py
